; ====================
; A number of helper functions to check your designs, export to CAD, 
; update your design in CAD, etc.
; ====================
#use-added-syntax(jitx)
defpackage helpers :
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/utils/checks
  import ocdb/utils/generic-components

; =====================
; Run the design checks
; =====================
public defn run-check-on-design (circuit:Instantiable) :
  set-main-module(circuit) ; Treat the provided module as a design, and compile it.
  val main-module = ocdb/utils/generator-utils/run-final-passes(circuit) ; Analyze design with a pass
  set-main-module(main-module) ; Treat the provided module as a design, and compile it.
  run-checks("checks.txt")

; ====================
; Actual Export design
; ====================
defn export-to-cad () :
  set-paper(ANSI-A4)
  set-export-backend(`kicad)
  export-cad()

; ====================
; Export design to CAD
; ====================
public defn export-design () :
  set-export-board?(true)
  export-to-cad()

; ===================================
; Update CAD, keeping layout progress
; ===================================
public defn update-design () :
  set-export-board?(false)
  export-to-cad()

; =================
; Export BOM to tsv
; =================
public defn export-bill-of-materials () :
  set-bom-vendors(ocdb/utils/design-vars/APPROVED-DISTRIBUTOR-LIST)
  set-bom-design-quantity(ocdb/utils/design-vars/DESIGN-QUANTITY)
  export-bom()

; get a list of pins, ordered by their physical location
defstruct PinPos :
  x-loc: Double
  y-loc: Double
  my-pin: JITXObject

defn cw-pin-sort (comp:JITXObject, pinposes:Tuple<PinPos>) -> Tuple<PinPos> :
  ; extract only the SMD pads (ignore TH)
  val smd-poses = 
    for pos in pinposes seq? :
      if (get-pad-type(comp, property(my-pin(pos).pads)[0]) == SMD) :
        One(pos)
      else :
        None()
  var smd-poses-tuple = to-tuple(smd-poses)
  ; get groups based on y location
  val y-locs = Vector<Double>()
  for pos in smd-poses-tuple do :
    if not contains?(y-locs, y-loc(pos)) :
      add(y-locs y-loc(pos))
  ; sort based on x location, using groups, and switching direction every other group
  ; get the first row
  val first-row-poses = qsort{x-loc, _} $
    for pos in pinposes seq? :
      if (y-loc(pos) == y-locs[0]) :
        One(pos)
      else :
        None()
  ; get the second row
  val second-row-poses = qsort{x-loc, _} $
    for pos in pinposes seq? :
      if (y-loc(pos) == y-locs[1]) :
        One(pos)
      else :
        None()
  ; reverse the second row so it's now sorted right to left
  val second-row-poses-reversed = reverse(to-list(second-row-poses))
  val sorted-pins = to-tuple(cat(second-row-poses-reversed, first-row-poses))
  sorted-pins

public defn get-pins-physically-ordered (comp:JITXObject) -> Tuple<JITXObject> :
  ; get all of the pins in the components
  val pins-list = pins(comp)
  ; use the PinPos object above to pack together our pins and pin locations
  val pin-pos = 
    ; get a map of pins to pad locations
    for my-pin in pins-list seq :
      val pad-pos = center(get-pad-pose(comp, property(my-pin.pads)[0]))
      PinPos(x(pad-pos), y(pad-pos), my-pin)
  val pin-pos-tuple = to-tuple(pin-pos)
  ; order the pins based on pad position in a counterclockwise fashion
  val sorted-pin-pos = cw-pin-sort(comp, pin-pos-tuple)
  ; extract just the pins from the sorted list
  val sorted-pins = 
    for pin-pos in sorted-pin-pos seq : 
      my-pin(pin-pos)
  val sorted-pins-tuple = to-tuple(sorted-pins)
  sorted-pins-tuple
 
; get the location of a pad
defn get-pad-pose (obj:JITXObject, pad-ref:VarRef|IndexRef) : 
  get-pad-pose(obj, pad-ref, false) 

defn get-pad-pose (obj:JITXObject, pad-ref:VarRef|IndexRef, pad-num:Int|False) -> Pose: 
  val landpattern-pads = pads( landpattern(instance-definition(obj)) )
  match(pad-num) :
    (pad-num:Int) :
      pose(find!({ref(_) == Ref(pad-ref)[pad-num]}, landpattern-pads))
    (pad-num:False) :
      pose(find!({ref(_) == pad-ref}, landpattern-pads))

; get the type of a pad
defn get-pad-type (obj:JITXObject, pad-ref:VarRef|IndexRef) : 
  get-pad-type(obj, pad-ref, false) 

defn get-pad-type (obj:JITXObject, pad-ref:VarRef|IndexRef, pad-num:Int|False) -> PadType: 
  val landpattern-pads = pads( landpattern(instance-definition(obj)) )
  match(pad-num) :
    (pad-num:Int) :
      pad-type(pad(find!({ref(_) == Ref(pad-ref)[pad-num]}, landpattern-pads)))
    (pad-num:False) :
      pad-type(pad(find!({ref(_) == pad-ref}, landpattern-pads)))


public defn get-named-net (my-pin:JITXObject) :
  var my-net
  inside pcb-module :
    label<False> my-break:
      for item in all-connected-items(self) do :
        if contains?(component-pins(item), my-pin) :
          for n in nets(item) do:
            match(ref?(n):Ref) :
              my-net = n
              my-break(false)
  my-net

pcb-material copper :
  type = Conductor
  name = "Copper"
  
pcb-material core :
  type = Dielectric
  dielectric-coefficient = 4.26
  name = "PR4 Core"

pcb-material soldermask :
  type = Dielectric
  dielectric-coefficient = 3.9
  name = "Taiyo BSN4000"

public pcb-stackup jlcpcb-jlc-2layer:
  name = "JLCPCB 2-layer 1.6mm"
  layer(0.019, soldermask) ; 0.5mil over conductor
  layer(0.035, copper) 
  layer(1.2650, core)
  layer(0.035, copper) 
  layer(0.019, soldermask) ; 0.5mil over conductor