; Generated by JITX 2.7.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import ocdb/utils/checks
  import helpers
  import ocdb/utils/property-structs
  import ocdb/utils/bundles
  import ocdb/utils/design-vars
  import ocdb/utils/generator-utils
  import ocdb/utils/netlist-checks/utils
  import bundles

MIN-CAP-VOLTAGE = 6.0

; Define the shape/size of the board
; 30.0x30.0 board with 2.0x5.0 cuts on 2 sides
val board-shape = Polygon([Point(-15.0,-15.0), Point(10.0,-15.0), Point(10.0,-13.0), Point(15.0,-13.0), Point(15.0, 13.0), Point(10.0, 13.0), Point(10.0, 15.0), Point(-15.0,15.0)])

; Setup the board
defn setup-board () :
  set-board(ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/bay-area-circuits-2-layer-62-mil, board-shape))
  set-rules(ocdb/manufacturers/rules/jlcpcb-rules)

; Taken from ocdb/utils/netlist-checks/io-checks.stanza and modified
pcb-check resistor-on-cc-usb-c (component:JITXObject):
  #CHECK(
    condition = cc-has-resistor(component),
    name = "Check if there is a pull up or pulldown resistor on the USB C CC pin"
    description = ""
    category = CATEGORY
    subcheck-description = "Check that CC pins have at least one resistor",
    pass-message = "CC pins have at least one pullup resistor",
    fail-message = "CC pins don't have a pullup resistor attached",
    locators = [instance-definition(component)]
  )

pcb-module usb-2-on-usb-c-male :
  port usb-c : usb-c
  port usb-2 : usb-2
  
  inst conn : database-part(["mpn" => "TYPE-C-31-G-03", "manufacturer" => "HRO Electronics"])
  place(conn) at loc(0.0,0.0,0.0) on Top
  property(conn.rated-temperature) = false

  property(usb-2.vbus.vdd) = PowerSupplyPin(typ(5.0), 0.5)

  net (usb-2.vbus.gnd usb-c.vbus.gnd conn.GND1 conn.GND3 conn.GND4 conn.GND5 conn.GND6)
  net (usb-2.vbus.vdd usb-c.vbus.vdd conn.VBUS0 conn.VBUS1)
  net (usb-2.data.N usb-c.data[1].N usb-c.data[2].N conn.DN1)
  net (usb-2.data.P usb-c.data[1].P usb-c.data[2].P conn.DP1)
  net (usb-c.cc[1] conn.CC1)
  net (usb-c.rx[1].N conn.SSRXN1)
  net (usb-c.rx[1].P conn.SSRXP1)
  net (usb-c.tx[1].N conn.SSTXN1)
  net (usb-c.tx[1].P conn.SSTXP1)

  ; GND0 and GND2 are connected to the shield
  res-strap(usb-2.vbus.gnd, conn.GND0, ["resistance" => 100.0e3, "_exist" => ["vendor_part_numbers.lcsc"]])
  bypass-cap-strap(usb-2.vbus.gnd, conn.GND2, ["capacitance" => 0.1e-6, "_exist" => ["vendor_part_numbers.lcsc"]])

  res-strap(usb-c.cc[1], usb-c.vbus.gnd, 5.1e3)

  check resistor-on-cc-usb-c(self)


pcb-module sd-connector :
  port conn : sd-card-uhs-1-connector

  inst sd : database-part(["mpn" => "SD-101", "manufacturer" => "XUNPU"])
  place(sd) at loc(0.0,0.0,0.0) on Top
  
  net (conn.power.gnd sd.VSS1 sd.VSS2 sd.SHELL0 sd.SHELL1 sd.SHELL2 sd.SHELL3)
  net (conn.power.vdd sd.VDD)

  net (conn.CMD sd.CMD)
  net (conn.CLK sd.CLK)
  net (conn.DAT[0] sd.DAT0)
  net (conn.DAT[1] sd.DAT1)
  net (conn.DAT[2] sd.DAT2)
  net (conn.DAT[3] sd.CD_DAT3)
  net (conn.CD sd.CD)
  net (conn.WP sd.WP)

; Module to run as a design
pcb-module sd-card-reader :
  val d = dims(board-shape)
  add-mounting-holes(Rectangle(x(d) - 2.0, y(d) - 2.0), "M2", [1 3])

  inst logo : ocdb/artwork/jitx-logo/logo(5.0)

  ; Call all our modules
  inst usb : usb-2-on-usb-c-male
  place(usb) at loc(x(d) / 2.0 + 1.1, 0.0, -270.0) on Bottom

  inst reg : components/bd433/voltage-regulator

  inst eeprom : components/m24c04/eeprom

  val testpoints = add-testpoint([eeprom.power.vdd eeprom.power.gnd eeprom.i2c.sda eeprom.i2c.scl], Testpoint-SMDPad)

  inst media-controller : components/usb2240/media-controller
  place(media-controller) at loc(0.0, 0.0, 0.0) on Top

  inst sd-connector : sd-connector
  place(sd-connector) at loc(-5.0, 0.0, 270.0) on Bottom

  net vdd50 (usb.usb-2.vbus.vdd)
  net vdd33 (reg.power-out.vdd)
  net gnd (usb.usb-2.vbus.gnd)


  inst status-led : components/LED-maker-ROYGB/module(components/LED-maker-ROYGB/RED, property(vdd33.voltage))

  ; Connect the modules together
  net (usb.usb-2.vbus reg.power-in)
  net (usb.usb-2 media-controller.usb-in)

  net (reg.power-out media-controller.power eeprom.power)

  net (media-controller.i2c eeprom.i2c)
  net (media-controller.sd-card-conn sd-connector.conn)

  net (media-controller.LED status-led.in)
  net (status-led.out gnd)

  symbol(vdd50) = ocdb/utils/symbols/supply-sym
  symbol(vdd33) = ocdb/utils/symbols/supply-sym
  symbol(gnd) = ocdb/utils/symbols/ground-sym

  geom(gnd) :
    copper-pour(LayerIndex(0), isolate = 0.1, rank = 1, orphans = true) = board-shape
    copper-pour(LayerIndex(1), isolate = 0.1, rank = 1, orphans = true) = board-shape

  val power-net-class = NetClass(`Power, [`min-trace => 0.381])
  property(gnd.net-class) = power-net-class
  property(vdd33.net-class) = power-net-class
  property(vdd50.net-class) = power-net-class

  property(gnd.voltage) = typ(0.0)
  property(vdd33.voltage) = min-max(3.0, 3.6)
  property(vdd50.voltage) = min-max(4.5, 5.5)

  schematic-group([media-controller, sd-connector, eeprom, status-led]) = data
  layout-group([media-controller, sd-connector, eeprom, status-led]) = data

  schematic-group([usb, reg]) = Vin
  layout-group([usb, reg]) = Vin

  schematic-group([testpoints]) = test
  layout-group([testpoints]) = test

  check-design(self)

; Set the design name - a directory with this name will be generated under the "designs" directory
set-current-design("jitx-design")

; Set the schematic sheet size
set-paper(ANSI-A)

; Setup the board properties
setup-board()

set-use-layout-groups()


; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(sd-card-reader)

; Use any helper function from helpers.stanza here
run-check-on-design(sd-card-reader)

; View the results
view-design-explorer()
view-board()
view-schematic()

;set-export-backend(`kicad)
;export-design()
