; Generated by JITX 2.28.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import ocdb/utils/defaults

  import helpers
  import custom_stackups

  import jsl/protocols/usb
  import jsl/bundles
  import jsl/pin-assignment
  import jsl/si/helpers
  import jsl/si/signal-ends
  import jsl/si/constraints

; Define the shape/size of the board
val board-shape = RoundedRectangle(45.67, 25.4, 1.61)

pcb-module power-regulation :
  port vbus : power
  port power-3v3 : power

  inst buck : components/Texas-Instruments/TPS6208x/module(vout-V = 3.3)

  net (vbus, buck.vin)
  net (power-3v3, buck.vout)

  net GND (vbus.V-)
  net pwr5v0 (vbus.V+)
  net pwr3v3 (power-3v3.V+)

  symbol(GND) = ocdb/utils/symbols/ground-sym
  symbol(pwr5v0) = ocdb/utils/symbols/supply-sym
  symbol(pwr3v3) = ocdb/utils/symbols/supply-sym

doc: \<DOC>
ESD Protection Generator

This module instantiates some number of ESD protection devices and 
then combines the supports from all of these devices in one module.
This allows the higher level code to construct a PA problem where
differential pairs and single-ended signals can use the appropriate 
ESD protection channel without requiring any pin swapping in code.

It "Just Works" (TM)
<DOC>
pcb-module esd-protection :
  pin GND

  inst IC : components/Texas-Instruments/TPDxE05U06/component(channels = 6)[2]

  for i in 0 to length(IC) do:
    net (IC[i].GND, GND)
    for j in 0 to 3 do:
      supports dual-pair:
        require ch:dual-pair from IC[i]
        dual-pair.A.P => ch.A.P
        dual-pair.A.N => ch.A.N
        dual-pair.B.P => ch.B.P
        dual-pair.B.N => ch.B.N

    for j in 0 to 6 do:
      supports pass-through:
        require pt:pass-through from IC[i]
        pass-through.A => pt.A
        pass-through.B => pt.B

; Module to run as a design
pcb-module my-design :
  ; Connectors 
  inst usb-c : components/Molex/_2012670005/module
  inst usb-a : components/XKB-Connectivity/U231-096N-3BLRT06-SS/module

  ; Power
  inst power : power-regulation
  net (usb-a.conn.vbus usb-c.conn.vbus power.vbus)

  ; USB SuperSpeed Mux 
  inst usb3-mux : components/Texas-Instruments/HD3SS3220RNHR/module

  net (usb3-mux.power-3v3, power.power-3v3)
  net (usb3-mux.power-5v, usb-c.conn.vbus)
  net (usb3-mux.usb-c.cc, usb-c.conn.bus.cc)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; USB 2.0 Interface
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; USB2 Repeater
  inst usb2-driver : components/Texas-Instruments/TUSB211IRWBR/module
  net (usb2-driver.power, power.power-3v3)

  inst util-esd : components/Texas-Instruments/TPDxE05U06/component(channels = 4)

  ; require repeater : dual-pair from usb2-driver
  ; require esd-data : dual-pair from util-esd

  val usb2-src = usb-a.conn.bus.data
  val usb2-dst = usb-c.conn.bus.data

  ; Set the topology of the USB2 data diff-pair
  ; topo-net(
  ;   usb2-src =>
  ;   esd-data.A =>
  ;   esd-data.B =>
  ;   repeater.A =>
  ;   repeater.B =>
  ;   usb2-dst,
  ;   [
  ;     "TypeA-to-ESD"
  ;     "ESD-underside"
  ;     "ESD-to-Repeater"
  ;     "Repeater-underside"
  ;     "Repeater-to-TypeC"
  ;   ]
  ; )

  ; Set the constraints on the defined USB2 topology.
  val usb2-constraint = USB-Constraint(proto = USB2, route-struct = diff-90)
  within [src, dst] = constrain-topology(usb2-src => usb2-dst, usb2-constraint):
    require repeater : dual-pair from usb2-driver
    require esd-data : dual-pair from util-esd

    topo-net(
      src =>
      esd-data.A =>
      esd-data.B =>
      repeater.A =>
      repeater.B =>
      dst
    )


  ; val [skew-2, loss-2] = usb-get-skew-loss(USB2)
  ; skew-window(skew-2, usb2-src => usb2-dst)
  ; max-loss(loss-2, usb2-src => usb2-dst)
  ; diff-structure(diff-90, usb2-src => usb2-dst)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; USB-C Superspeed Interface
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  inst ss-esd : esd-protection
  net GND (power.vbus.V-, ss-esd.GND, util-esd.GND)

  val usb3-constraint = USB-Constraint(proto = USB3, route-struct = diff-90)
  for i in 0 to length(usb3-mux.usb-c.lane) do:
    ; This `constraint-topology` should be applied to the `lane[i]` not
    ;   the individual diff-pairs - but I don't have the infrastructure
    ;   yet to support this.
    within [src, dst] = constrain-topology(
      usb3-mux.usb-c.lane[i].TX => usb-c.conn.bus.lane[i].TX,
      usb3-constraint
      ):
      require prot : dual-pair from ss-esd
      topo-net(src => prot.A => prot.B => dst)

    within [src, dst] = constrain-topology(
      usb3-mux.usb-c.lane[i].RX => usb-c.conn.bus.lane[i].RX,
      usb3-constraint
      ):
      require prot : dual-pair from ss-esd
      topo-net(src => prot.A => prot.B => dst)


  ; There are two super-speed lanes from the connector to the MUX
  ;  We connect them with ESD protection in between.
  ; require esd-1 : dual-pair[2] from ss-esd
  ; topo-net(usb3-mux.usb-c.lane[0].TX => esd-1[0].A => esd-1[0].B => usb-c.conn.bus.lane[0].TX)
  ; topo-net(usb3-mux.usb-c.lane[0].RX => esd-1[1].A => esd-1[1].B => usb-c.conn.bus.lane[0].RX)

  ; require esd-2 : dual-pair[2] from ss-esd
  ; topo-net(usb3-mux.usb-c.lane[1].TX => esd-2[0].A => esd-2[0].B => usb-c.conn.bus.lane[1].TX)
  ; topo-net(usb3-mux.usb-c.lane[1].RX => esd-2[1].A => esd-2[1].B => usb-c.conn.bus.lane[1].RX)
  
  ; val [skew-3, loss-3] = usb-get-skew-loss(USB3)
  ; for i in 0 to 2 do:
  ;   ; Sometimes when the topology is complex, we won't necessarily be
  ;   ; able to access the true endpoint of the topology from the top-level
  ;   ; design. The `Signal Ends` provides a mechanism for accessing internal
  ;   ; ports to find the endpoint of a topology.
  ;   val tx-src = get-signal-end(usb3-mux.usb-c.lane[i].TX)
  ;   val tx-dst = usb-c.conn.bus.lane[i].TX
  ;   val rx-dst = get-signal-end(usb3-mux.usb-c.lane[i].RX)
  ;   val rx-src = usb-c.conn.bus.lane[i].RX
  ;   ; Set Constrains on each diff-pair of the lanes.
  ;   diff-structure(
  ;     diff-90,
  ;     tx-src => tx-dst,
  ;     rx-dst => rx-src
  ;   )
  ;   skew-window(
  ;     skew-3
  ;     tx-src => tx-dst,
  ;     rx-dst => rx-src
  ;   )
  ;   max-loss(
  ;     loss-3,
  ;     tx-src => tx-dst,
  ;     rx-dst => rx-src
  ;     )


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; USB-A Superspeed Interface
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  

  ; NOTE: Because we are using a type-A connector which 
  ;  is typically the host - we must swap the TX / RX 
  ;  pairs.
  ;  This is why the TX on Mux => RX on Connector
  ;    and RX on Mux => TX on Connector
  ; val conn-tx-ep = usb-a.conn.bus.lane[0].RX
  ; val conn-rx-ep = usb-a.conn.bus.lane[0].TX

  constrain-topology(
    usb3-mux.usb-a.lane[0].RX => usb-a.conn.bus.lane[0].TX,
    usb3-constraint
  )

  constrain-topology(
    usb3-mux.usb-a.lane[0].TX => usb-a.conn.bus.lane[0].RX,
    usb3-constraint
  )



  ; topo-net(usb3-mux.usb-a.lane[0].RX => conn-rx-ep, ["A-SSRX"])
  ; topo-net(usb3-mux.usb-a.lane[0].TX => conn-tx-ep, ["A-SSTX"])

  ; val mux-rx-ep = get-signal-end(usb3-mux.usb-a.lane[0].RX)
  ; val mux-tx-ep = get-signal-end(usb3-mux.usb-a.lane[0].TX)

  ; diff-structure(
  ;   diff-90,
  ;   mux-tx-ep => conn-tx-ep,
  ;   mux-rx-ep => conn-rx-ep,
  ;   )

  ; skew-window(
  ;   skew-3,
  ;   mux-tx-ep => conn-tx-ep,
  ;   mux-rx-ep => conn-rx-ep,
  ; )

  ; max-loss(
  ;   loss-3,
  ;   mux-tx-ep => conn-tx-ep,
  ;   mux-rx-ep => conn-rx-ep,
  ;   )

  require pt : pass-through[4] from ss-esd
  net SBU0 (pt[0].A, usb-c.conn.bus.sbu[0])
  net CC0 (pt[1].A, usb-c.conn.bus.cc[0])
  net SBU1 (pt[2].A, usb-c.conn.bus.sbu[1])
  net CC1 (pt[3].A, usb-c.conn.bus.cc[1])

  geom(GND) :
    copper-pour(LayerIndex(1), isolate = 0.125, rank = 1) = board-shape
    copper-pour(LayerIndex(4), isolate = 0.125, rank = 1) = board-shape
    
; Set the design name - a directory with this name will be generated under the "designs" directory
set-current-design("USB-A-to-C")


public pcb-board my-board (outline:Shape) :
  stackup = sierra-circuits-6-layer-100z-dif
  boundary = outline
  signal-boundary = outline
  vias = [default-via minimum-via]


; Setup the board
defn setup-board () :
  set-board(my-board(board-shape))
  set-rules(custom_rules/sierra-circuits-notouch-rules-100z-diff) ;manufacturing rules

; Set the schematic sheet size
set-paper(ANSI-B)

; Setup the board properties
setup-board()

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(my-design)

; Use any helper function from helpers.stanza here
; run-check-on-design(my-design)

; View the results
view-board()
view-schematic()
view-design-explorer()

set-bom-design-quantity(100)

set-bom-metrics([
  BOMMetric(BOMMetricLineItems, "Line Items"),
  BOMMetric(BOMMetricComponentCount, "Components"),
  BOMMetric(BOMMetricTotalCost, "Cost")
])

set-bom-columns([
  BOMColumn(BOMFieldStatus, "Status", 10.0)
  BOMColumn(BOMFieldInsts, "References", 10.0)
  BOMColumn(BOMFieldMPN, "MPN", 10.0)
  BOMColumn(BOMFieldDescription, "Description", 20.0)
  BOMColumn(BOMFieldVendor, "Supplier", 10.0)
  BOMColumn(BOMFieldQuantity, "Qty", 5.0)
  BOMColumn(BOMFieldSubtotal, "Total", 5.0)
  BOMColumn(BOMFieldPreferred, "Preferred", 5.0)
])

view-bom(BOM-STD)