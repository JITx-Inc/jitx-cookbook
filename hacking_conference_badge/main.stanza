; Generated by JITX 1.1.2-rc.2
#use-added-syntax(jitx)
defpackage main :
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/utils/defaults
  import ocdb/utils/landpatterns
  import ocdb/utils/box-symbol
  import ocdb/utils/bundles
  import ocdb/utils/generic-components
  import ocdb/utils/symbols
  import ocdb/utils/property-structs
  import ocdb/utils/checks
  import ocdb/utils/generator-utils
  import ocdb/utils/connects
  import ocdb/utils/design-vars
  import checks
  import helpers

; Implement other modules used by our design 
; ==========================================
MIN-CAP-VOLTAGE = 10.0
DESIGN-QUANTITY = 1
val board-shape = RoundedRectangle(110.0, 52.0, 0.25)

; ==========================================
; Configure the design, then run or check it
; ==========================================
defn run-design (circuit:Instantiable, run-checks?:True|False) :
  ; set-paper(ANSI-A5)
  set-current-design("hackathon-2022")
  set-board(ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/jlcpcb-jlc2313-6layer, board-shape))
  set-rules(ocdb/manufacturers/rules/jlcpcb-rules)

  ; We may have to fix db-parts on the fly, and want people to get fixes automatically.
  ; Okay to always send queries for the hackathon.
  ; clear-dbquery-cache()

  var main-module = circuit

  if run-checks? :
    main-module = ocdb/utils/generator-utils/run-final-passes(circuit) ; Analyze design with a pass
  
  set-main-module(main-module) ; Treat the provided module as a design, and compile it.
  set-use-layout-groups()
  if run-checks? :
    run-checks("checks.txt")
    view-design-explorer()
    export-design()
  else:  
    view-board()
    view-schematic()
    view-design-explorer()

pcb-module serial-RGB (num:Int):
  pin vdd-5V
  pin vdd-3V3
  pin gnd
  pin din

  inst led : database-part(["manufacturer" => "Worldsemi", "mpn" => "WS2816C-2121"])[num]
  for i in 0 to num - 1 do :
    net (led[i].BO led[i + 1].BI)
    net (led[i].DO led[i + 1].DI)
    net (led[i].VDD led[i + 1].VDD vdd-5V)
    net (led[i].GND led[i + 1].GND gnd)
    place(led[i]) at loc(3.0 * to-double(i), 0.0) on Top
  place(led[num - 1]) at loc(3.0 * to-double(num - 1), 0.0) on Top
  net (led[0].BI gnd)

  ; NFET level shifter
  inst q : database-part(["manufacturer" => "Shikues", "mpn" => "BSN20"])
  net (q.G vdd-3V3)
  net (q.S din)
  net (q.D led[0].DI)
  res-strap(q.D vdd-5V, 1.0e3)
  schematic-group(self) = ws2816
  layout-group(self) = ws2816

pcb-module led-grid (x:Int, y:Int):
  val num-leds = x * y
  pin a
  port k : pin[num-leds]
  inst led : database-part(["mpn" => "KT-0603白灯", "manufacturer" => "Hubei KENTO Elec"])[num-leds]
  for (i in 0 to num-leds, pose in grid-locs(x, y, 3.5, 3.5)) do :
    net (led[i].A a)
    net (k[i] led[i].K)
    place(led[i]) at pose * loc(0.0, 0.0, 45.0) on Top
  schematic-group(self) = grid
  layout-group(self) = grid

pcb-module rgb-grid (x:Int, y:Int):
  val num-leds = x * y
  pin a
  port rgb : rgb-led[num-leds]
  ;inst led : database-part(["manufacturer" => "Foshan NationStar Optoelectronics", "mpn" => "FM-B2020RGBA-HG"])[num-leds] ; not in stock at JLCPCB
  inst led : database-part(["manufacturer" => "Foshan NationStar Optoelectronics", "mpn" => "NH-Z1921RGBA-SF"])[num-leds] ; in stock at JLCPCB
  for (i in 0 to num-leds, pose in grid-locs(x, y, 3.5, 3.5)) do :
    ; net (led[i].A a)
    ; net (rgb[i].r led[i].K0)
    ; net (rgb[i].g led[i].K1)
    ; net (rgb[i].b led[i].K2)
    net (a led[i].p[1])
    net (rgb[i].r led[i].R)
    net (rgb[i].g led[i].G)
    net (rgb[i].b led[i].B)
    place(led[i]) at pose * loc(0.0, 0.0, 45.0) on Top

  schematic-group(self) = rgb-grid
  layout-group(self) = rgb-grid

public pcb-module led-driver :
  pin vdd
  pin gnd
  port i2c : i2c

  public inst u : components/IS31FL3236A-QFLS2-TR/component
  bypass-cap-strap(u.VCC, gnd, 2.2e-6)
  net (u.VCC vdd)
  net (u.GND[0] u.GND[1] u.EPAD gnd u.AD)
  net (vdd u.SDB)
  net (i2c.sda u.SDA)
  net (i2c.scl u.SCL)
  res-strap(u.R-EXT gnd, 3.3e3)
  schematic-group(self) = led-driver
  layout-group(self) = led-driver

public pcb-module key-matrix :
  port row : pin[2]
  port column : pin[4]

  for i in 0 to 2 do : 
    for j in 0 to 4 do : 
      inst d : database-part(["manufacturer" => "ST(Semtech)", "mpn" => "1N4148W"])
      ;inst sw : database-part(["manufacturer" => "C&K", "mpn" => "PTS810SJM250SMTRLFS"]) ; black, out of stock at JLCPCB
      inst sw : database-part(["mpn" => "PTS810SJK250SMTRLFS", "manufacturer" => "C&K"]) ; white, in stock at JLCPCB
      net (sw.p[1], d.K)
      net (sw.p[3] row[i])
      net (d.A column[j])
      val c = loc(7.5 * to-double(j), 7.5 * to-double(i))
      place(sw) at c on Top
      place(d) at c * loc(0.0, 3.0, 180.0) on Top
      schematic-group(sw) = col[i] 
      schematic-group(d) = col[i] 

public pcb-module class-d-audio :
  pin in 
  pin vdd
  pin gnd
  pin en

  ; Low pass the PWM @ 20 KHz
  inst r : chip-resistor(closest-std-val(80.0, 5.0))
  net (r.p[1] in )
  cap-strap(r.p[2] gnd, 0.1e-6)

  inst d : database-part(["manufacturer" => "Diodes Incorporated", "mpn" => "PAM8302AADCR"])

  ;inst vol : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130AP5"]) ; out of stock at JLCPCB
  inst vol : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130ACL"]) ; in stock at JLCPCB
  net (vol.p[3] r.p[2])
  cap-strap(vol.p[2], d.IN+, 0.1e-6)
  cap-strap(vol.p[1], d.IN-, 0.1e-6)

  net (d.VDD vdd)
  bypass-cap-strap(d.VDD, gnd, 10.0e-6)
  net (d.GND gnd)
  net (d.SD_NOT en)

  inst speaker : pin-header(2)
  net (speaker.p[1] d.VO-)
  net (speaker.p[2] d.VO+)
  do-not-populate(speaker)
  schematic-group(self) = class-d
  layout-group(self) = class-d

; =========================
; Module to run as a design
; ==========================
public pcb-module buddha :
  ; USB
  ;inst usb : usb2-on-a-usb-c-connector(ocdb/components/korean-hroparts-elec/TYPE-C-31-M-12/module(SinkDefault))
  inst usb : usb2-on-a-usb-c-connector(ocdb/components/korean-hroparts-elec/TYPE-C-31-M-23/module(SinkDefault))
  ; inst usb : usb2-on-a-usb-c-connector()
  net GND (usb.usb-2.vbus.gnd)
  symbol(GND) = ground-sym
  property(GND.voltage) = typ(0.0)
  ;; set net classes for usb
  ; val usb-net-class = NetClass(`USB-net-class, [`min-trace => 0.8])
  ; net USB-NET-DN (usb.con.conn.DN1)
  ; net USB-NET-DP (usb.con.conn.DP1)
  ; property(USB-NET-DP.net-class) = usb-net-class
  ; property(USB-NET-DP.net-class) = usb-net-class

  ; Power - battery
  inst battery : database-part(["vendor_part_numbers.lcsc" => "C47647"])
  net (battery.p[1] GND)

  ; battery charging
  inst charger : components/BQ24078RGTR/module
  net VBAT (battery.p[2] charger.bat+)
  net (charger.gnd GND)

  ; power switch
  inst sw : database-part(["manufacturer" => "G-Switch", "mpn" => "MK-12C02-G025"])
  net SW-VOUT (sw.p[2] charger.vout)
  net P4V2 (sw.p[3])
  property(P4V2.voltage) = min-max(3.5 5.0)
  net VBUS (charger.vin usb.usb-2.vbus.vdd)

  ; power - LDO
  inst ld : components/AP2125K-2_8TRG1/module
  net (P4V2 ld.vin ld.en)
  net (ld.gnd, GND)
  net P2V8 (ld.vout)

  ; set net symbols
  symbol(VBAT) = supply-sym
  symbol(VBUS) = supply-sym
  symbol(P4V2) = supply-sym
  symbol(P2V8) = supply-sym

  ; RP2040
  inst rpi : components/RP2040/module
  net (GND rpi.gnd)
  net (usb.usb-2.data rpi.usb)
  schematic-group(rpi) = rpi
  layout-group(rpi) = rpi
  net (rpi.vdd P2V8)

  ; Serial LEDs
  inst w : serial-RGB(10)
  require led-data : gpio from rpi.mcu
  net (led-data.gpio w.din)
  net (w.vdd-5V P4V2)
  net (w.vdd-3V3 P2V8)
  net (w.gnd GND)

  ; LED driver
  inst led-drive : led-driver
  net (led-drive.gnd GND)
  net (led-drive.vdd P4V2)
  require rpi-led-i2c : i2c from rpi.mcu
  ; net (l.i2c, led-i2c)
  ; val i2c-pu = add-open-drain-pullups(l.i2c, P2V8)

  ; LED driver I2C level shifter
  inst led-driver-shifter : components/logic-level-shifter/i2c-level-shifter-module
  net (led-driver-shifter.gnd GND) 
  net (led-driver-shifter.lv P2V8) 
  net (led-driver-shifter.hv P4V2) 
  net (led-driver-shifter.lv-i2c rpi-led-i2c) 
  net (led-driver-shifter.hv-i2c led-drive.i2c) 

  schematic-group(led-driver-shifter) = schematic-group(led-drive)

  ;below there are two white grids and two high side switches. We use the switches to switch between the two banks.
  ; Switched single-color led grids
  inst white-grid : led-grid(3,3)[2]

  ; inst en-sw : hi-side-sw(2)[2]
  inst en-sw : components/high-side-switch/high-side-switch()[2]
  require enable : gpio[2] from rpi.mcu

  require drive : gpio[9] from led-drive.u
  for i in 0 to 2 do :
    net (en-sw[i].power.vdd  P4V2)
    net (en-sw[i].power.gnd  GND)
    net (en-sw[i].input enable[i].gpio)
    net (en-sw[i].output white-grid[i].a)
    schematic-group(en-sw[i]) = schematic-group(white-grid[i])
    layout-group(en-sw[i]) = layout-group(white-grid[i])
    for j in 0 to 9 do :
      net (white-grid[i].k[j] drive[j].gpio)

  ; RGB grid
  val rgb-x = 3
  val rgb-y = 3
  inst rgb-grid : rgb-grid(rgb-x, rgb-y)
  net (rgb-grid.a P4V2)
  require rgb-drive : gpio[27] from led-drive.u
  for i in 0 to rgb-x * rgb-y do :
    net (rgb-grid.rgb[i].r rgb-drive[i * 3].gpio)
    net (rgb-grid.rgb[i].g rgb-drive[i * 3 + 1].gpio)
    net (rgb-grid.rgb[i].b rgb-drive[i * 3 + 2].gpio)
  schematic-group(rgb-grid) = rgb-grid

  ; Key Matrix
  inst keys : key-matrix
  require rows : gpio[2] from rpi.mcu
  require cols : gpio[4] from rpi.mcu
  for i in 0 to 2 do :
    net (keys.row[i] rows[i].gpio)
  for i in 0 to 4 do :
    net (keys.column[i] cols[i].gpio)
  schematic-group(keys) = keys

  ; Speaker
  inst amp : class-d-audio
  require pwm : timer from rpi.mcu
  require audio-enable : gpio from rpi.mcu
  net (pwm.timer, amp.in)
  net (audio-enable.gpio, amp.en)
  net (P4V2 amp.vdd)
  net (GND amp.gnd)

  ; Knobs
  ;inst knobs : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130AP5"]) ; out of stock at JLCPCB
  inst knobs : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130ACL"])[4] ; in stock at JLCPCB
  for i in 0 to 4 do :
    require in : adc from rpi.mcu
    net (in.adc knobs[i].p[2])
    net (knobs[i].p[1] rpi.vdd)
    net (knobs[i].p[3] GND)
  schematic-group(knobs) = knobs
  layout-group(knobs) = knobs

  ; Distance sensor
  inst tof : components/VL53L0CXV0DH_1/module

  require tof-i2c : i2c from rpi.mcu
  net (tof.i2c tof-i2c)
  add-open-drain-pullups(tof.i2c, P2V8)

  net (tof.power.vdd P2V8)
  net (tof.power.gnd GND)
  require tof-en : gpio from rpi.mcu
  net (tof-en.gpio tof.x-shut)
  res-strap(tof.x-shut, P2V8, 8.2e3)

  ; create copper pours
  geom(GND) :
    copper-pour(LayerIndex(1), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)
  geom(P4V2) :
    copper-pour(LayerIndex(2), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)
  geom(GND) :
    copper-pour(LayerIndex(3), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)
  geom(P2V8) :
    copper-pour(LayerIndex(4), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)

  ; set net classes for power
  val power-net-class = NetClass(`Power-HV, [`min-trace => 0.381])
  property(GND.net-class) = power-net-class
  property(P4V2.net-class) = power-net-class
  property(VBUS.net-class) = power-net-class
  property(VBAT.net-class) = power-net-class
  property(SW-VOUT.net-class) = power-net-class
  val low-power-net-class = NetClass(`Power-LV, [`min-trace => 0.254])
  property(P2V8.net-class) = low-power-net-class

  check-design(self)

run-design(buddha, false)