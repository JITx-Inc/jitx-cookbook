; Generated by JITX 2.8.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import ocdb/utils/property-structs
  import ocdb/utils/bundles
  import ocdb/utils/checks
  import ocdb/utils/design-vars
  import ocdb/utils/generator-utils 
  import helpers

; Define the shape/size of the board
val board-shape = RoundedRectangle(50.0, 50.0, 0.25)

; Setup the board
defn setup-board () :
  set-board(ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/jlcpcb-jlc2313, board-shape))
  set-rules(ocdb/manufacturers/rules/jlcpcb-rules)

defn bypass-cap-strap (power-pin:JITXObject, gnd-pin:JITXObject, capacitance:Double|Toleranced|False = false -- params:Tuple<KeyValue>, tol:Double|False = false) -> JITXObject :
  inside pcb-module:
    if capacitance:
      if tol:
        val cap = bypass-cap-strap(power-pin, gnd-pin, params = ["capacitance" => capacitance "tolerance" => tol])
        cap
      else:
        val cap = bypass-cap-strap(power-pin, gnd-pin, params = ["capacitance" => capacitance])
        cap
    else:
      val cap = cap-strap(gnd-pin, power-pin, params)
      short-trace(cap.p[2], power-pin)
      cap

pcb-bundle stereo-audio:
  pin left
  pin right
  pin gnd

; Mostly reused from the quickstarts
pcb-module regulator (output-voltage:Toleranced) :
  port power-in : power
  port power-out : power
  pin adj

  inst ams1117 : database-part(["manufacturer" => "Advanced Monolithic Systems", "mpn" => "AMS1117-ADJ"])

  property(ams1117.rated-temperature) = min-max(0.0,125.0)
  property(ams1117.reference-voltage) = min-typ-max(1.225, 1.25, 1.27)
  property(ams1117.minimum-load) = 10.0e-3
  property(ams1117.adj-current) = 55.0e-6
  property(ams1117.max-current) = 0.8
  property(ams1117.In.power-pin) = PowerPin(DualOffsetVoltage(1.5, 12.0, ams1117.Out))
  property(ams1117.mounting) = "smd"

  net (power-in.vdd ams1117.In)
  net (power-out.vdd ams1117.Out)

  net gnd (power-in.gnd power-out.gnd ams1117.TAB)

  bypass-cap-strap(ams1117.Out, gnd, 22.0e-6)
  bypass-cap-strap(ams1117.ADJ, gnd, 10.0e-6)

  ; How much variability can we expect from the regulator alone?
  val refVoltage = property(ams1117.reference-voltage)
  val inherent-variance = tol+%(refVoltage)
  if inherent-variance > tol+%(output-voltage):
    fatal("Target design accuracy infeasible with AMS1117 %_ > %_" % [inherent-variance tol+%(output-voltage)])

  ; Budget variability for the voltage divider
  val target-variance = tol+%(output-voltage) - inherent-variance

  ; 10mA of voltage-divider current to compensate for regulator adj current
  val divider-current = 10.0e-3
  val adj-current = property(ams1117.adj-current) ; retrieve the property from the component definition

  ; Estimate offset voltage caused by current sourced from adj pin
  val est-v-adj-offset = (typ-value(output-voltage) - typ-value(refVoltage)) / divider-current * adj-current

  inst output-voltage-divider : ocdb/modules/passive-circuits/voltage-divider(high-voltage, adj-voltage, current) where :
    val high-voltage = tol%(center-value(output-voltage) - est-v-adj-offset, 0.0)
    val adj-voltage = tol%(typ-value(refVoltage),target-variance)
    val current = divider-current

  schematic-group(self) = ams1117
  layout-group(self) = ams1117

  net (output-voltage-divider.in ams1117.Out) 
  net (output-voltage-divider.out ams1117.ADJ adj) 
  net (output-voltage-divider.lo gnd)


pcb-module audio-codec :
  port usb : usb-2
  port audio-in : stereo-audio
  port audio-out : stereo-audio
  port power33 : power
  pin mute

  inst pcm2900 : database-part(["manufacturer" => "Texas Instruments", "mpn" => "PCM2900CDBR"])

  property(pcm2900.rated-temperature) = min-max(-40.0,125.0)
  property(pcm2900.mounting) = "smd"

  property(pcm2900.D+.digital-io) = DigitalIO(CMOSOutput(min-max(0.0,0.3), min-max(2.8,4.0)), min-max(0.0,0.8), min-max(2.0,3.3), pcm2900.VDDI, pcm2900.DGNDU, 10.0e-6)
  property(pcm2900.D-.digital-io) = DigitalIO(CMOSOutput(min-max(0.0,0.3), min-max(2.8,4.0)), min-max(0.0,0.8), min-max(2.0,3.3), pcm2900.DGNDU, pcm2900.VDDI, 10.0e-6)

  val hid-properties = DigitalInput(min-max(0.0, 0.9), min-max(2.52, 3.3), pcm2900.SSPND_NOT, pcm2900.DGND, 50.0e-6)
  property(pcm2900.HID0.digital-input) = hid-properties
  
  ; We want our volume to be controlled from the amp instead
  no-connect(pcm2900.HID1)
  no-connect(pcm2900.HID2)

  property(pcm2900.SEL0.digital-input) = DigitalInput(min-max(0.0, 0.8), min-max(2.0, 5.25), pcm2900.SSPND_NOT, pcm2900.DGND, 10.0e-6)
  property(pcm2900.SEL1.digital-input) = DigitalInput(min-max(0.0, 0.8), min-max(2.0, 5.25), pcm2900.SSPND_NOT, pcm2900.DGND, 10.0e-6)

  property(pcm2900.SSPND_NOT.digital-output) = DigitalOutput(CMOSOutput(min-max(0.0, 0.5), min-max(2.8, 3.5)), false, pcm2900.DGND, pcm2900.VDDI)

  no-connect(pcm2900.TEST1)

  property(pcm2900.VBUS.power-pin) = PowerPin(min-typ-max(4.35, 5.0, 5.25))

  property(pcm2900.XTI.digital-input) = DigitalInput(min-max(0.0, 0.9), min-max(2.52, 3.3), pcm2900.XTO, pcm2900.AGNDX, 10.0e-6)

  net gnd (usb.vbus.gnd pcm2900.DGNDU, pcm2900.DGND, pcm2900.TEST0, pcm2900.AGNDX, pcm2900.AGNDC audio-in.gnd audio-out.gnd, power33.gnd)

  res-strap(usb.data.P, pcm2900.D+, 22.0)
  res-strap(usb.data.P, pcm2900.VDDI, 1500.0)

  res-strap(usb.data.N, pcm2900.D-, 22.0)

  res-strap(usb.vbus.vdd, pcm2900.VBUS, 2.2)
  bypass-cap-strap(usb.vbus.vdd, gnd, 1.0e-6)

  bypass-cap-strap(pcm2900.VCOM, gnd, 10.0e-6)
  bypass-cap-strap(pcm2900.VCCCI, gnd, 10.0e-6)
  bypass-cap-strap(pcm2900.VDDI, gnd, 1.0e-6)
  bypass-cap-strap(pcm2900.VCCXI, gnd, 1.0e-6)
  bypass-cap-strap(pcm2900.VCCP2I, gnd, 1.0e-6)
  bypass-cap-strap(pcm2900.VCCP1I, gnd, 1.0e-6)

  net (audio-in.left pcm2900.VINL)
  net (audio-in.right pcm2900.VINR)

  net (audio-out.left pcm2900.VOUTL)
  net (audio-out.right pcm2900.VOUTR)

  inst diode : database-part(["manufacturer" => "TOSHIBA", "mpn" => "CUS10S30,H3F"])
  property(diode.rated-temperature) = min-max(-25.0, 125.0)
  net (diode.K pcm2900.VCCCI)
  net (power33.vdd diode.A)

  inst mute-button : ocdb/components/te-connectivity/1825910-6/component
  net (mute-button.P pcm2900.HID0)
  res-strap(mute-button.T, pcm2900.SSPND_NOT, 1500.0)
  net (mute pcm2900.SSPND_NOT)

  inst xtal : database-part(["manufacturer" => "TAE(Zhejiang Abel Elec)", "mpn" => "TAXM12M4RLBDDT2T"])
  property(xtal.rated-temperature) = min-max(-30.0, 85.0)
  property(xtal.crystal-resonator) = ocdb/utils/property-structs/CrystalResonator(20.0e-12, 5.0e-12, 5.0e-15, 50.0, 12.0e6, 20.0e-6, 100.0e-6)

  val stray-capacitance = shunt-capacitance(property(xtal.crystal-resonator))
  val c-load = load-capacitance(property(xtal.crystal-resonator))
  val c-bal = closest-std-val(2.0 * (c-load - stray-capacitance), 5.0)
  bypass-cap-strap(xtal.OSC1, gnd, params = ["capacitance" => c-bal "temperature-coefficient.code" => "C0G"])
  bypass-cap-strap(xtal.OSC2, gnd, params = ["capacitance" => c-bal "temperature-coefficient.code" => "C0G"])
  net (gnd xtal.GND0 xtal.GND1)
  net (xtal.OSC1 pcm2900.XTI)
  net (xtal.OSC2 pcm2900.XTO)
  res-strap(pcm2900.XTI, pcm2900.XTO, 1.0e6)

pcb-module audio-connector-with-mic :
  port audio : stereo-audio
  pin mic

  inst conn : database-part(["manufacturer" => "XKB Connectivity", "mpn" => "PJ-342B-TX-SMT"])
  net (conn.p[5] audio.gnd)
  net (conn.p[2] mic)
  net (conn.p[3] audio.left)
  net (conn.p[6] audio.right)

pcb-module big-audio-connector :
  port audio : stereo-audio

  inst conn : database-part(["manufacturer" => "HOOYA", "mpn" => "PJ-611C"])

pcb-module amp :
  port power : power
  port audio-in : stereo-audio
  port audio-out : stereo-audio

  inst amp : database-part(["manufacturer" => "Texas Instruments", "mpn" => "TPA3110D2PWPR"])

  property(amp.rated-temperature) = min-max(-40.0, 85.0)
  property(amp.mounting) = "smd"

  property(amp.SD_NOT.digital-input)
  property(amp.FAULT_NOT.digital-output)
  ;ignore LINP LINN
  property(amp.GAIN0.digital-input)
  property(amp.GAIN1.digital-input)
  property(amp.AVCC.power-pin)
  ;ignore GVDD PLIMIT
  property()
  

; Module to run as a design
pcb-module audio-interface :
  inst usb : usb2-on-a-usb-c-connector()
  inst audio-codec : audio-codec
  inst reg : regulator(min-max(3.6,3.85))
  inst amp : amp

  inst headphones : audio-connector-with-mic
  inst speaker : big-audio-connector
  inst mic-2 : big-audio-connector

  net gnd (usb.usb-2.vbus.gnd)

  net (usb.usb-2.vbus reg.power-in)
  bypass-cap-strap(reg.power-in.vdd, gnd, 1.0e-6)

  net (reg.power-out audio-codec.power33)
  net (usb.usb-2 audio-codec.usb)



; Set the design name - a directory with this name will be generated under the "designs" directory
set-current-design("jitx-design")

; Set the schematic sheet size
set-paper(ANSI-A)

; Setup the board properties
setup-board()

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(audio-interface)

; Use any helper function from helpers.stanza here
; run-check-on-design(my-design)

; View the results
view-board()
view-schematic()
view-design-explorer()
