; Generated by JITX 3.0.0
#use-added-syntax(jitx)
defpackage keyboard-generator :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import helpers
  import ocdb/scripts/kle-importer

var n-rows = 0
var n-cols = 0

pcb-landpattern key-accesories-land (k:KeyCap):
  val bounds = bounds(k)
  val width = width(bounds)
  val height = height(bounds)
  val s = "" when length(string(k)) == 0 else string(k)[0]
  layer(Silkscreen("f-silk", Top)) = Text(s, 2.0, C, loc(0.0, -4.0))
  layer(Silkscreen("f-silk", Top)) = outline $ Rectangle(width - 1.0, height - 1.0)
  
  val w = width / UNIT
  if w >= 2.0 : 
    ;println("width: %_" % [width])
    val a = 
      if w  < 3.0 :
        23.876
      else if w  == 3.0: 
        38.1
      else if w == 6.25: 
        100.0
      else if w == 7.0:
        114.3
      else if w <= 10.0:
        133.35
      else: 
        0.0 ; unreachable
    ; Flip the Spacebar stabilizer to save vertical space
    if w >= 6.0 :
      layer(Cutout()) = Circle(Point(a / 2.0, -6.985), 3.048 / 2.0) 
      layer(Cutout()) = Circle(Point(a / 2.0, 8.255), 3.9878 / 2.0)
      layer(Cutout()) = Circle(Point(a / -2.0, -6.985), 3.048 / 2.0) 
      layer(Cutout()) = Circle(Point(a / -2.0, 8.255), 3.9878 / 2.0)

    else:
      layer(Cutout()) = Circle(Point(a / 2.0, 6.985), 3.048 / 2.0) 
      layer(Cutout()) = Circle(Point(a / 2.0, -8.255), 3.9878 / 2.0)
      layer(Cutout()) = Circle(Point(a / -2.0, 6.985), 3.048 / 2.0) 
      layer(Cutout()) = Circle(Point(a / -2.0, -8.255), 3.9878 / 2.0)

public pcb-component key-accesories (k:KeyCap): 
  val land = key-accesories-land(k)
  landpattern = land()
  val sym = ocdb/utils/symbols/unplated-hole-sym
  symbol = sym()

public pcb-module keyboard-from-kle (kle-json-path:String -- button:Instantiable):
  val keycaps = parse-kle $ kle-json-path
  val size = length $ keys $ keycaps
  val [num-rows, num-cols] = dimensions(keycaps)
  
  val row? = Array<True|False>(num-rows, false)
  val col? = Array<True|False>(num-cols, false)

  for key in keys $ keycaps do : 
    row?[row(key)] = true 
    col?[col(key)] = true
  
  val row-indices = to-tuple $ seq?(fn (i): if row?[i]: One(i) else: None(), 0 to num-rows)
  val col-indices = to-tuple $ seq?(fn (i): if col?[i]: One(i) else: None(), 0 to num-cols)

  ; println("%, \n %,"% [row-indices, col-indices])
  ;fatal("")
  port r : pin[row-indices]
  port c : pin[col-indices]

  for [key, idx] in zip(keys(keycaps), 0 to false) do : 
    val text = "%@" % [string $ key]
    inst sw : button
    inst silk : key-accesories(key)
    net (sw.r r[row(key)])
    net (sw.c c[col(key)])

    place(sw) at pose(bounds(key)) on Top
    place(silk) at pose(bounds(key)) on Top
    schematic-group(sw) = col[col(key)] 
    component-status(silk) :
      bom-status = NotInBOM